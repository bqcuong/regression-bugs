package com.peterphi.std.guice.common.logging.logreport;


// This file was generated by colf(1); DO NOT EDIT


import static java.lang.String.format;
import java.util.InputMismatchException;
import java.nio.BufferOverflowException;
import java.nio.BufferUnderflowException;


/**
 * Data bean with built-in serialization support.
 * @author generated by colf(1)
 * @see <a href="https://github.com/pascaldekloe/colfer">Colfer's home</a>
 */
public class LogLine implements java.io.Serializable {

	/** The upper limit for serial byte sizes. */
	public static int colferSizeMax = 16 * 1024 * 1024;

	/** The upper limit for the number of elements in a list. */
	public static int colferListMax = 64 * 1024;

	private static final java.nio.charset.Charset _utf8 = java.nio.charset.Charset.forName("UTF-8");

	public long when;
	public String category = "";
	public int level;
	public String requestUri = "";
	public String thread = "";
	public String userId = "";
	public String traceId = "";
	public String exceptionId = "";
	public String exception = "";
	public String message = "";


	/**
	 * Serializes the object.
	 * @param buf the data destination.
	 * @param offset the initial index for {@code buf}, inclusive.
	 * @return the final index for {@code buf}, exclusive.
	 * @throws BufferOverflowException when {@code buf} is too small.
	 * @throws IllegalStateException on an upper limit breach defined by either {@link #colferSizeMax} or {@link #colferListMax}.
	 */
	public int marshal(byte[] buf, int offset) {
		int i = offset;
		try {
			if (this.when != 0) {
				long x = this.when;
				if (x < 0) {
					x = -x;
					buf[i++] = (byte) (0 | 0x80);
				} else
					buf[i++] = (byte) 0;
				for (int n = 0; n < 8 && (x & ~0x7fL) != 0; n++) {
					buf[i++] = (byte) (x | 0x80);
					x >>>= 7;
				}
				buf[i++] = (byte) x;
			}

			if (! this.category.isEmpty()) {
				buf[i++] = (byte) 1;
				int start = ++i;

				String s = this.category;
				for (int sIndex = 0, sLength = s.length(); sIndex < sLength; sIndex++) {
					char c = s.charAt(sIndex);
					if (c < '\u0080') {
						buf[i++] = (byte) c;
					} else if (c < '\u0800') {
						buf[i++] = (byte) (192 | c >>> 6);
						buf[i++] = (byte) (128 | c & 63);
					} else if (c < '\ud800' || c > '\udfff') {
						buf[i++] = (byte) (224 | c >>> 12);
						buf[i++] = (byte) (128 | c >>> 6 & 63);
						buf[i++] = (byte) (128 | c & 63);
					} else {
						int cp = 0;
						if (++sIndex < sLength) cp = Character.toCodePoint(c, s.charAt(sIndex));
						if ((cp >= 1 << 16) && (cp < 1 << 21)) {
							buf[i++] = (byte) (240 | cp >>> 18);
							buf[i++] = (byte) (128 | cp >>> 12 & 63);
							buf[i++] = (byte) (128 | cp >>> 6 & 63);
							buf[i++] = (byte) (128 | cp & 63);
						} else
							buf[i++] = (byte) '?';
					}
				}
				int size = i - start;
				if (size > colferSizeMax)
					throw new IllegalStateException(format("colfer: field com/peterphi/std/guice/common/logging/logreport.LogLine.category size %d exceeds %d UTF-8 bytes", size, colferSizeMax));

				int ii = start - 1;
				if (size > 0x7f) {
					i++;
					for (int x = size; x >= 1 << 14; x >>>= 7) i++;
					System.arraycopy(buf, start, buf, i - size, size);

					do {
						buf[ii++] = (byte) (size | 0x80);
						size >>>= 7;
					} while (size > 0x7f);
				}
				buf[ii] = (byte) size;
			}

			if (this.level != 0) {
				int x = this.level;
				if ((x & ~((1 << 21) - 1)) != 0) {
					buf[i++] = (byte) (2 | 0x80);
					buf[i++] = (byte) (x >>> 24);
					buf[i++] = (byte) (x >>> 16);
					buf[i++] = (byte) (x >>> 8);
					buf[i++] = (byte) (x);
				} else {
					buf[i++] = (byte) 2;
					while (x > 0x7f) {
						buf[i++] = (byte) (x | 0x80);
						x >>>= 7;
					}
					buf[i++] = (byte) x;
				}
			}

			if (! this.requestUri.isEmpty()) {
				buf[i++] = (byte) 3;
				int start = ++i;

				String s = this.requestUri;
				for (int sIndex = 0, sLength = s.length(); sIndex < sLength; sIndex++) {
					char c = s.charAt(sIndex);
					if (c < '\u0080') {
						buf[i++] = (byte) c;
					} else if (c < '\u0800') {
						buf[i++] = (byte) (192 | c >>> 6);
						buf[i++] = (byte) (128 | c & 63);
					} else if (c < '\ud800' || c > '\udfff') {
						buf[i++] = (byte) (224 | c >>> 12);
						buf[i++] = (byte) (128 | c >>> 6 & 63);
						buf[i++] = (byte) (128 | c & 63);
					} else {
						int cp = 0;
						if (++sIndex < sLength) cp = Character.toCodePoint(c, s.charAt(sIndex));
						if ((cp >= 1 << 16) && (cp < 1 << 21)) {
							buf[i++] = (byte) (240 | cp >>> 18);
							buf[i++] = (byte) (128 | cp >>> 12 & 63);
							buf[i++] = (byte) (128 | cp >>> 6 & 63);
							buf[i++] = (byte) (128 | cp & 63);
						} else
							buf[i++] = (byte) '?';
					}
				}
				int size = i - start;
				if (size > colferSizeMax)
					throw new IllegalStateException(format("colfer: field com/peterphi/std/guice/common/logging/logreport.LogLine.requestUri size %d exceeds %d UTF-8 bytes", size, colferSizeMax));

				int ii = start - 1;
				if (size > 0x7f) {
					i++;
					for (int x = size; x >= 1 << 14; x >>>= 7) i++;
					System.arraycopy(buf, start, buf, i - size, size);

					do {
						buf[ii++] = (byte) (size | 0x80);
						size >>>= 7;
					} while (size > 0x7f);
				}
				buf[ii] = (byte) size;
			}

			if (! this.thread.isEmpty()) {
				buf[i++] = (byte) 4;
				int start = ++i;

				String s = this.thread;
				for (int sIndex = 0, sLength = s.length(); sIndex < sLength; sIndex++) {
					char c = s.charAt(sIndex);
					if (c < '\u0080') {
						buf[i++] = (byte) c;
					} else if (c < '\u0800') {
						buf[i++] = (byte) (192 | c >>> 6);
						buf[i++] = (byte) (128 | c & 63);
					} else if (c < '\ud800' || c > '\udfff') {
						buf[i++] = (byte) (224 | c >>> 12);
						buf[i++] = (byte) (128 | c >>> 6 & 63);
						buf[i++] = (byte) (128 | c & 63);
					} else {
						int cp = 0;
						if (++sIndex < sLength) cp = Character.toCodePoint(c, s.charAt(sIndex));
						if ((cp >= 1 << 16) && (cp < 1 << 21)) {
							buf[i++] = (byte) (240 | cp >>> 18);
							buf[i++] = (byte) (128 | cp >>> 12 & 63);
							buf[i++] = (byte) (128 | cp >>> 6 & 63);
							buf[i++] = (byte) (128 | cp & 63);
						} else
							buf[i++] = (byte) '?';
					}
				}
				int size = i - start;
				if (size > colferSizeMax)
					throw new IllegalStateException(format("colfer: field com/peterphi/std/guice/common/logging/logreport.LogLine.thread size %d exceeds %d UTF-8 bytes", size, colferSizeMax));

				int ii = start - 1;
				if (size > 0x7f) {
					i++;
					for (int x = size; x >= 1 << 14; x >>>= 7) i++;
					System.arraycopy(buf, start, buf, i - size, size);

					do {
						buf[ii++] = (byte) (size | 0x80);
						size >>>= 7;
					} while (size > 0x7f);
				}
				buf[ii] = (byte) size;
			}

			if (! this.userId.isEmpty()) {
				buf[i++] = (byte) 5;
				int start = ++i;

				String s = this.userId;
				for (int sIndex = 0, sLength = s.length(); sIndex < sLength; sIndex++) {
					char c = s.charAt(sIndex);
					if (c < '\u0080') {
						buf[i++] = (byte) c;
					} else if (c < '\u0800') {
						buf[i++] = (byte) (192 | c >>> 6);
						buf[i++] = (byte) (128 | c & 63);
					} else if (c < '\ud800' || c > '\udfff') {
						buf[i++] = (byte) (224 | c >>> 12);
						buf[i++] = (byte) (128 | c >>> 6 & 63);
						buf[i++] = (byte) (128 | c & 63);
					} else {
						int cp = 0;
						if (++sIndex < sLength) cp = Character.toCodePoint(c, s.charAt(sIndex));
						if ((cp >= 1 << 16) && (cp < 1 << 21)) {
							buf[i++] = (byte) (240 | cp >>> 18);
							buf[i++] = (byte) (128 | cp >>> 12 & 63);
							buf[i++] = (byte) (128 | cp >>> 6 & 63);
							buf[i++] = (byte) (128 | cp & 63);
						} else
							buf[i++] = (byte) '?';
					}
				}
				int size = i - start;
				if (size > colferSizeMax)
					throw new IllegalStateException(format("colfer: field com/peterphi/std/guice/common/logging/logreport.LogLine.userId size %d exceeds %d UTF-8 bytes", size, colferSizeMax));

				int ii = start - 1;
				if (size > 0x7f) {
					i++;
					for (int x = size; x >= 1 << 14; x >>>= 7) i++;
					System.arraycopy(buf, start, buf, i - size, size);

					do {
						buf[ii++] = (byte) (size | 0x80);
						size >>>= 7;
					} while (size > 0x7f);
				}
				buf[ii] = (byte) size;
			}

			if (! this.traceId.isEmpty()) {
				buf[i++] = (byte) 6;
				int start = ++i;

				String s = this.traceId;
				for (int sIndex = 0, sLength = s.length(); sIndex < sLength; sIndex++) {
					char c = s.charAt(sIndex);
					if (c < '\u0080') {
						buf[i++] = (byte) c;
					} else if (c < '\u0800') {
						buf[i++] = (byte) (192 | c >>> 6);
						buf[i++] = (byte) (128 | c & 63);
					} else if (c < '\ud800' || c > '\udfff') {
						buf[i++] = (byte) (224 | c >>> 12);
						buf[i++] = (byte) (128 | c >>> 6 & 63);
						buf[i++] = (byte) (128 | c & 63);
					} else {
						int cp = 0;
						if (++sIndex < sLength) cp = Character.toCodePoint(c, s.charAt(sIndex));
						if ((cp >= 1 << 16) && (cp < 1 << 21)) {
							buf[i++] = (byte) (240 | cp >>> 18);
							buf[i++] = (byte) (128 | cp >>> 12 & 63);
							buf[i++] = (byte) (128 | cp >>> 6 & 63);
							buf[i++] = (byte) (128 | cp & 63);
						} else
							buf[i++] = (byte) '?';
					}
				}
				int size = i - start;
				if (size > colferSizeMax)
					throw new IllegalStateException(format("colfer: field com/peterphi/std/guice/common/logging/logreport.LogLine.traceId size %d exceeds %d UTF-8 bytes", size, colferSizeMax));

				int ii = start - 1;
				if (size > 0x7f) {
					i++;
					for (int x = size; x >= 1 << 14; x >>>= 7) i++;
					System.arraycopy(buf, start, buf, i - size, size);

					do {
						buf[ii++] = (byte) (size | 0x80);
						size >>>= 7;
					} while (size > 0x7f);
				}
				buf[ii] = (byte) size;
			}

			if (! this.exceptionId.isEmpty()) {
				buf[i++] = (byte) 7;
				int start = ++i;

				String s = this.exceptionId;
				for (int sIndex = 0, sLength = s.length(); sIndex < sLength; sIndex++) {
					char c = s.charAt(sIndex);
					if (c < '\u0080') {
						buf[i++] = (byte) c;
					} else if (c < '\u0800') {
						buf[i++] = (byte) (192 | c >>> 6);
						buf[i++] = (byte) (128 | c & 63);
					} else if (c < '\ud800' || c > '\udfff') {
						buf[i++] = (byte) (224 | c >>> 12);
						buf[i++] = (byte) (128 | c >>> 6 & 63);
						buf[i++] = (byte) (128 | c & 63);
					} else {
						int cp = 0;
						if (++sIndex < sLength) cp = Character.toCodePoint(c, s.charAt(sIndex));
						if ((cp >= 1 << 16) && (cp < 1 << 21)) {
							buf[i++] = (byte) (240 | cp >>> 18);
							buf[i++] = (byte) (128 | cp >>> 12 & 63);
							buf[i++] = (byte) (128 | cp >>> 6 & 63);
							buf[i++] = (byte) (128 | cp & 63);
						} else
							buf[i++] = (byte) '?';
					}
				}
				int size = i - start;
				if (size > colferSizeMax)
					throw new IllegalStateException(format("colfer: field com/peterphi/std/guice/common/logging/logreport.LogLine.exceptionId size %d exceeds %d UTF-8 bytes", size, colferSizeMax));

				int ii = start - 1;
				if (size > 0x7f) {
					i++;
					for (int x = size; x >= 1 << 14; x >>>= 7) i++;
					System.arraycopy(buf, start, buf, i - size, size);

					do {
						buf[ii++] = (byte) (size | 0x80);
						size >>>= 7;
					} while (size > 0x7f);
				}
				buf[ii] = (byte) size;
			}

			if (! this.exception.isEmpty()) {
				buf[i++] = (byte) 8;
				int start = ++i;

				String s = this.exception;
				for (int sIndex = 0, sLength = s.length(); sIndex < sLength; sIndex++) {
					char c = s.charAt(sIndex);
					if (c < '\u0080') {
						buf[i++] = (byte) c;
					} else if (c < '\u0800') {
						buf[i++] = (byte) (192 | c >>> 6);
						buf[i++] = (byte) (128 | c & 63);
					} else if (c < '\ud800' || c > '\udfff') {
						buf[i++] = (byte) (224 | c >>> 12);
						buf[i++] = (byte) (128 | c >>> 6 & 63);
						buf[i++] = (byte) (128 | c & 63);
					} else {
						int cp = 0;
						if (++sIndex < sLength) cp = Character.toCodePoint(c, s.charAt(sIndex));
						if ((cp >= 1 << 16) && (cp < 1 << 21)) {
							buf[i++] = (byte) (240 | cp >>> 18);
							buf[i++] = (byte) (128 | cp >>> 12 & 63);
							buf[i++] = (byte) (128 | cp >>> 6 & 63);
							buf[i++] = (byte) (128 | cp & 63);
						} else
							buf[i++] = (byte) '?';
					}
				}
				int size = i - start;
				if (size > colferSizeMax)
					throw new IllegalStateException(format("colfer: field com/peterphi/std/guice/common/logging/logreport.LogLine.exception size %d exceeds %d UTF-8 bytes", size, colferSizeMax));

				int ii = start - 1;
				if (size > 0x7f) {
					i++;
					for (int x = size; x >= 1 << 14; x >>>= 7) i++;
					System.arraycopy(buf, start, buf, i - size, size);

					do {
						buf[ii++] = (byte) (size | 0x80);
						size >>>= 7;
					} while (size > 0x7f);
				}
				buf[ii] = (byte) size;
			}

			if (! this.message.isEmpty()) {
				buf[i++] = (byte) 9;
				int start = ++i;

				String s = this.message;
				for (int sIndex = 0, sLength = s.length(); sIndex < sLength; sIndex++) {
					char c = s.charAt(sIndex);
					if (c < '\u0080') {
						buf[i++] = (byte) c;
					} else if (c < '\u0800') {
						buf[i++] = (byte) (192 | c >>> 6);
						buf[i++] = (byte) (128 | c & 63);
					} else if (c < '\ud800' || c > '\udfff') {
						buf[i++] = (byte) (224 | c >>> 12);
						buf[i++] = (byte) (128 | c >>> 6 & 63);
						buf[i++] = (byte) (128 | c & 63);
					} else {
						int cp = 0;
						if (++sIndex < sLength) cp = Character.toCodePoint(c, s.charAt(sIndex));
						if ((cp >= 1 << 16) && (cp < 1 << 21)) {
							buf[i++] = (byte) (240 | cp >>> 18);
							buf[i++] = (byte) (128 | cp >>> 12 & 63);
							buf[i++] = (byte) (128 | cp >>> 6 & 63);
							buf[i++] = (byte) (128 | cp & 63);
						} else
							buf[i++] = (byte) '?';
					}
				}
				int size = i - start;
				if (size > colferSizeMax)
					throw new IllegalStateException(format("colfer: field com/peterphi/std/guice/common/logging/logreport.LogLine.message size %d exceeds %d UTF-8 bytes", size, colferSizeMax));

				int ii = start - 1;
				if (size > 0x7f) {
					i++;
					for (int x = size; x >= 1 << 14; x >>>= 7) i++;
					System.arraycopy(buf, start, buf, i - size, size);

					do {
						buf[ii++] = (byte) (size | 0x80);
						size >>>= 7;
					} while (size > 0x7f);
				}
				buf[ii] = (byte) size;
			}

			buf[i++] = (byte) 0x7f;
			return i;
		} catch (IndexOutOfBoundsException e) {
			if (i - offset > colferSizeMax)
				throw new IllegalStateException(format("colfer: serial exceeds %d bytes", colferSizeMax));
			if (i >= buf.length)
				throw new BufferOverflowException();
			throw e;
		}
	}

	/**
	 * Deserializes the object.
	 * @param buf the data source.
	 * @param offset the initial index for {@code buf}, inclusive.
	 * @return the final index for {@code buf}, exclusive.
	 * @throws BufferUnderflowException when {@code buf} is incomplete. (EOF)
	 * @throws SecurityException on an upper limit breach defined by either {@link #colferSizeMax} or {@link #colferListMax}.
	 * @throws InputMismatchException when the data does not match this object's schema.
	 */
	public int unmarshal(byte[] buf, int offset) {
		int i = offset;
		try {
			byte header = buf[i++];

			if (header == (byte) 0) {
				long x = 0;
				for (int shift = 0; true; shift += 7) {
					byte b = buf[i++];
					if (shift == 56 || b >= 0) {
						x |= (b & 0xffL) << shift;
						break;
					}
					x |= (b & 0x7fL) << shift;
				}
				this.when = x;
				header = buf[i++];
			} else if (header == (byte) (0 | 0x80)) {
				long x = 0;
				for (int shift = 0; true; shift += 7) {
					byte b = buf[i++];
					if (shift == 56 || b >= 0) {
						x |= (b & 0xffL) << shift;
						break;
					}
					x |= (b & 0x7fL) << shift;
				}
				this.when = -x;
				header = buf[i++];
			}

			if (header == (byte) 1) {
				int size = 0;
				for (int shift = 0; true; shift += 7) {
					byte b = buf[i++];
					size |= (b & 0x7f) << shift;
					if (shift == 28 || b >= 0) break;
				}
				if (size > colferSizeMax)
					throw new SecurityException(format("colfer: field com/peterphi/std/guice/common/logging/logreport.LogLine.category size %d exceeds %d UTF-8 bytes", size, colferSizeMax));

				int start = i;
				i += size;
				this.category = new String(buf, start, size, this._utf8);
				header = buf[i++];
			}

			if (header == (byte) 2) {
				int x = 0;
				for (int shift = 0; true; shift += 7) {
					byte b = buf[i++];
					x |= (b & 0x7f) << shift;
					if (shift == 28 || b >= 0) break;
				}
				this.level = x;
				header = buf[i++];
			} else if (header == (byte) (2 | 0x80)) {
				this.level = (buf[i++] & 0xff) << 24 | (buf[i++] & 0xff) << 16 | (buf[i++] & 0xff) << 8 | (buf[i++] & 0xff);
				header = buf[i++];
			}

			if (header == (byte) 3) {
				int size = 0;
				for (int shift = 0; true; shift += 7) {
					byte b = buf[i++];
					size |= (b & 0x7f) << shift;
					if (shift == 28 || b >= 0) break;
				}
				if (size > colferSizeMax)
					throw new SecurityException(format("colfer: field com/peterphi/std/guice/common/logging/logreport.LogLine.requestUri size %d exceeds %d UTF-8 bytes", size, colferSizeMax));

				int start = i;
				i += size;
				this.requestUri = new String(buf, start, size, this._utf8);
				header = buf[i++];
			}

			if (header == (byte) 4) {
				int size = 0;
				for (int shift = 0; true; shift += 7) {
					byte b = buf[i++];
					size |= (b & 0x7f) << shift;
					if (shift == 28 || b >= 0) break;
				}
				if (size > colferSizeMax)
					throw new SecurityException(format("colfer: field com/peterphi/std/guice/common/logging/logreport.LogLine.thread size %d exceeds %d UTF-8 bytes", size, colferSizeMax));

				int start = i;
				i += size;
				this.thread = new String(buf, start, size, this._utf8);
				header = buf[i++];
			}

			if (header == (byte) 5) {
				int size = 0;
				for (int shift = 0; true; shift += 7) {
					byte b = buf[i++];
					size |= (b & 0x7f) << shift;
					if (shift == 28 || b >= 0) break;
				}
				if (size > colferSizeMax)
					throw new SecurityException(format("colfer: field com/peterphi/std/guice/common/logging/logreport.LogLine.userId size %d exceeds %d UTF-8 bytes", size, colferSizeMax));

				int start = i;
				i += size;
				this.userId = new String(buf, start, size, this._utf8);
				header = buf[i++];
			}

			if (header == (byte) 6) {
				int size = 0;
				for (int shift = 0; true; shift += 7) {
					byte b = buf[i++];
					size |= (b & 0x7f) << shift;
					if (shift == 28 || b >= 0) break;
				}
				if (size > colferSizeMax)
					throw new SecurityException(format("colfer: field com/peterphi/std/guice/common/logging/logreport.LogLine.traceId size %d exceeds %d UTF-8 bytes", size, colferSizeMax));

				int start = i;
				i += size;
				this.traceId = new String(buf, start, size, this._utf8);
				header = buf[i++];
			}

			if (header == (byte) 7) {
				int size = 0;
				for (int shift = 0; true; shift += 7) {
					byte b = buf[i++];
					size |= (b & 0x7f) << shift;
					if (shift == 28 || b >= 0) break;
				}
				if (size > colferSizeMax)
					throw new SecurityException(format("colfer: field com/peterphi/std/guice/common/logging/logreport.LogLine.exceptionId size %d exceeds %d UTF-8 bytes", size, colferSizeMax));

				int start = i;
				i += size;
				this.exceptionId = new String(buf, start, size, this._utf8);
				header = buf[i++];
			}

			if (header == (byte) 8) {
				int size = 0;
				for (int shift = 0; true; shift += 7) {
					byte b = buf[i++];
					size |= (b & 0x7f) << shift;
					if (shift == 28 || b >= 0) break;
				}
				if (size > colferSizeMax)
					throw new SecurityException(format("colfer: field com/peterphi/std/guice/common/logging/logreport.LogLine.exception size %d exceeds %d UTF-8 bytes", size, colferSizeMax));

				int start = i;
				i += size;
				this.exception = new String(buf, start, size, this._utf8);
				header = buf[i++];
			}

			if (header == (byte) 9) {
				int size = 0;
				for (int shift = 0; true; shift += 7) {
					byte b = buf[i++];
					size |= (b & 0x7f) << shift;
					if (shift == 28 || b >= 0) break;
				}
				if (size > colferSizeMax)
					throw new SecurityException(format("colfer: field com/peterphi/std/guice/common/logging/logreport.LogLine.message size %d exceeds %d UTF-8 bytes", size, colferSizeMax));

				int start = i;
				i += size;
				this.message = new String(buf, start, size, this._utf8);
				header = buf[i++];
			}

			if (header != (byte) 0x7f)
				throw new InputMismatchException(format("colfer: unknown header at byte %d", i - 1));
		} catch (IndexOutOfBoundsException e) {
			if (i - offset > colferSizeMax)
				throw new SecurityException(format("colfer: serial exceeds %d bytes", colferSizeMax));
			if (i >= buf.length)
				throw new BufferUnderflowException();
			throw new RuntimeException("colfer: bug", e);
		}

		if (i - offset > colferSizeMax)
			throw new SecurityException(format("colfer: serial exceeds %d bytes", colferSizeMax));
		return i;
	}

	public long getWhen() {
		return this.when;
	}

	public void setWhen(long value) {
		this.when = value;
	}

	public String getCategory() {
		return this.category;
	}

	public void setCategory(String value) {
		this.category = value;
	}

	public int getLevel() {
		return this.level;
	}

	public void setLevel(int value) {
		this.level = value;
	}

	public String getRequestUri() {
		return this.requestUri;
	}

	public void setRequestUri(String value) {
		this.requestUri = value;
	}

	public String getThread() {
		return this.thread;
	}

	public void setThread(String value) {
		this.thread = value;
	}

	public String getUserId() {
		return this.userId;
	}

	public void setUserId(String value) {
		this.userId = value;
	}

	public String getTraceId() {
		return this.traceId;
	}

	public void setTraceId(String value) {
		this.traceId = value;
	}

	public String getExceptionId() {
		return this.exceptionId;
	}

	public void setExceptionId(String value) {
		this.exceptionId = value;
	}

	public String getException() {
		return this.exception;
	}

	public void setException(String value) {
		this.exception = value;
	}

	public String getMessage() {
		return this.message;
	}

	public void setMessage(String value) {
		this.message = value;
	}

	@Override
	public final int hashCode() {
		int h = 1;
		h = 31 * h + (int)(this.when ^ this.when >>> 32);
		if (this.category != null) h = 31 * h + this.category.hashCode();
		h = 31 * h + this.level;
		if (this.requestUri != null) h = 31 * h + this.requestUri.hashCode();
		if (this.thread != null) h = 31 * h + this.thread.hashCode();
		if (this.userId != null) h = 31 * h + this.userId.hashCode();
		if (this.traceId != null) h = 31 * h + this.traceId.hashCode();
		if (this.exceptionId != null) h = 31 * h + this.exceptionId.hashCode();
		if (this.exception != null) h = 31 * h + this.exception.hashCode();
		if (this.message != null) h = 31 * h + this.message.hashCode();
		return h;
	}

	@Override
	public final boolean equals(Object o) {
		return o instanceof LogLine && equals((LogLine) o);
	}

	public final boolean equals(LogLine o) {
		return o != null
			&& this.when == o.when
			&& java.util.Objects.equals(this.category, o.category)
			&& this.level == o.level
			&& java.util.Objects.equals(this.requestUri, o.requestUri)
			&& java.util.Objects.equals(this.thread, o.thread)
			&& java.util.Objects.equals(this.userId, o.userId)
			&& java.util.Objects.equals(this.traceId, o.traceId)
			&& java.util.Objects.equals(this.exceptionId, o.exceptionId)
			&& java.util.Objects.equals(this.exception, o.exception)
			&& java.util.Objects.equals(this.message, o.message);
	}

}
