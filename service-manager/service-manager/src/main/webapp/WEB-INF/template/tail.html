<!DOCTYPE html SYSTEM "http://www.thymeleaf.org/dtd/xhtml1-strict-thymeleaf-3.dtd">
<html xmlns:th="http://www.thymeleaf.org">
<head>
	<meta th:substituteby="includes :: htmlhead"/>
	<title>Config Service</title>

	<style th:fragment="htmlhead">
		pre {
			font-size: 11px;
		}

		body {
			padding-bottom: 40px;
		}

		.dl-horizontal > dd:after {
			display: table;
			content: "";
			clear: both;
		}
	</style>
</head>

<body id="top">
<div class="container">
	<h1>Log Tail</h1>

	<div class="btn-toolbar">
		<div class="btn-group">
			<button class="btn dropdown-toggle" type="button" data-toggle="dropdown">Filter Endpoints<span
					id="filterEndpointsSummary"></span>
				<span class="caret"></span></button>
			<ul class="dropdown-menu" id="filterEndpointsOptions" style="padding-left: 10px; padding-right: 10px;">
				<li><em>No endpoints observed yet</em></li>
			</ul>
		</div>

		<div class="btn-group">
			<button class="btn dropdown-toggle" type="button" data-toggle="dropdown">Level<span
					id="filterLevelSummary"></span>
				<span class="caret"></span></button>
			<ul class="dropdown-menu" id="filterLevelOptions" style="padding-left: 10px;">
				<li><label class="radio control-label"><input type="radio" name="level" value="0" checked="checked"/> All</label>
				</li>
				<li><label class="radio control-label"><input type="radio" name="level" value="3"/> DEBUG</label></li>
				<li><label class="radio control-label"><input type="radio" name="level" value="4"/> INFO</label></li>
				<li><label class="radio control-label"><input type="radio" name="level" value="5"/> WARN</label></li>
				<li><label class="radio control-label"><input type="radio" name="level" value="6"/> ERROR</label></li>
				<li style="padding-bottom: 5px;"><label class="radio control-label"><input type="radio" name="level" value="7"/>
					FATAL</label></li>
			</ul>
		</div>


		<div class="btn-group">
			<button class="btn dropdown-toggle" type="button" data-toggle="dropdown">Endpoint Display<span
					id="renderEndpointSummary"> (short)</span>
				<span class="caret"></span></button>
			<ul class="dropdown-menu" id="renderEndpointOptions" style="padding-left: 10px;">
				<li><label class="radio control-label"><input type="radio" name="endpointRender" value="short" checked="checked"/>
					Short</label>
				</li>
				<li style="padding-bottom: 5px;"><label class="radio control-label"><input type="radio" name="endpointRender"
				                                                                           value="full"/> Full</label></li>
			</ul>
		</div>

		<div class="btn-group">
			<button class="btn" type="button" onclick="clearLines()">Clear</button>
		</div>
	</div>

	Your log tail subscription id is: <code th:text="${subscriptionId}"></code>

	<table class="table">
		<thead>
		<tr>
			<th class="span2 log_endpoint">Endpoint</th>
			<th class="span1 log_when">When</th>
			<th class="span1 log_level">Level</th>
			<th class="span7 log_message">Message</th>
		</tr>
		</thead>
		<tbody id="loglines" style="text-overflow: ellipsis;">
		<tr id="latest">
			<td colspan="4"><em>Monitoring for new lines...</em></td>
		</tr>
		</tbody>
	</table>

	<script th:inline="javascript">/*<![CDATA[*/
	var tailURL = /*[[@{/logs/tail.do}]]*/ '';
	var subscriptionId = /*[[${subscriptionId}]]*/ '';
	var nonce = /*[[${nonce}]]*/ '';

	$(document).ready(function () {
		$("#filterLevelOptions input[type=radio]").change(refilter);
		$("#renderEndpointOptions input[type=radio]").change(rerender);

		getRecentLines();
	});

	function getRecentLines() {
		$.ajax({
			type: "POST",
			dataType: 'json',
			url: tailURL,
			data: {
				'id': subscriptionId,
				'nonce': nonce
			},
			complete: function (data, textStatus) {
				if (textStatus == 'success') {
					addLines($.parseJSON(data.responseText));

					setTimeout(getRecentLines, 500);
				}
				else {
					var failureXML = data.responseXML;
					var latestLine = $("#latest td");

					if (failureXML) {
						var errorDetail = $($(failureXML).find("detail")[0]).text();

						latestLine.text("Server returned rich exception as a result of log request: " + errorDetail);
					}
					else {
						latestLine.text("Unknown problem occurred as a result of a log request: textStatus=" + textStatus);
					}
				}
			}
		});
	}

	var LEVEL_NAMES = ['0', '1', 'TRACE', 'DEBUG', 'INFO', 'WARN', 'ERROR', 'FATAL', '8', '9']
	var END_OF_LOG_TABLE = $("#latest");
	var MAX_SCROLLBACK_SIZE = 10000;
	var logLinesInMemory = 0;
	var lastTableRowMousedown = new Date(0);
	var ALL_ENDPOINTS = {};
	var ENDPOINT_RENDERER = endpointRenderShort;
	var MESSAGE_RENDERER = messageRendererDefault;
	var EVENT_FILTER = function () {
		return true;
	};
	var OVERRIDE_ENDPOINTS = {};

	function messageRendererDefault(event, td) {

		if (event.exceptionId && event.exceptionId.length > 0)
			td.text("!!" + event.exceptionId.substring(0, 4) + " " + event.message);
		else
			td.text(event.message);

		return td;
	}

	function endpointRenderShort(event) {
		var endpoint = event.endpoint;

		if (endpoint == "http://unknown") {
			return "";
		}
		else {
			// If the endpoint ends with /rest or /rest/ then we should remove that from it
			if (endpoint.endsWith("/rest/"))
				endpoint = endpoint.substring(0, endpoint.length - "/rest/".length);
			else if (endpoint.endsWith("/rest"))
				endpoint = endpoint.substring(0, endpoint.length - "/rest".length);

			var lastSlash = endpoint.lastIndexOf('/', endpoint.length - 1);

			if (lastSlash != -1)
				return endpoint.substring(lastSlash + 1);
			else
				return endpoint;
		}
	}

	function endpointRenderFull(event) {
		return event.endpoint;
	}

	function addLines(events) {
		if (events.length > 0) {
			// Allows us to keep track of whether the user was at the bottom of the page
			// If they were at the bottom of the page at the start of this method we should ensure they are at the end
			var isAtBottomOfPage = isElementInViewport(END_OF_LOG_TABLE);

			for (var i = 0; i < events.length; i++) {
				addLine(events[i]);
			}

			logLinesInMemory += events.length;

			// Keep within the scrollback buffer limit
			if (logLinesInMemory > MAX_SCROLLBACK_SIZE) {
				// Remove an additional 500 lines (so we aren't having to delete lines every time)
				var linesToRemove = (MAX_SCROLLBACK_SIZE - logLinesInMemory) + 500;

				clearLines(linesToRemove);
			}

			// Make sure to keep the last log line in view (if we were at the bottom of the page at the start of the method)
			if (isAtBottomOfPage) {
				END_OF_LOG_TABLE[0].scrollIntoView({
					behavior: "instant",
					block: "end"
				});
			}
		}
	}

	// Remove a set number of lines from the start of the buffer
	// If no number of lines is supplied then remove all lines
	function clearLines(linesToRemove) {
		if (linesToRemove === undefined || linesToRemove > logLinesInMemory) {
			linesToRemove = logLinesInMemory;
		}

		// Remove an additional 500 lines (so we aren't having to delete lines every time)
		$("#loglines tr").slice(0, linesToRemove).remove();

		logLinesInMemory -= linesToRemove;
	}


	var SHORT_TIMESTAMP_FORMAT = 'HH:mm:ss.SS';
	var LONG_TIMESTAMP_FORMAT = 'D MMM HH:mm:ss.SS';

	// Formats a timestamp string in the local timezone
	// N.B. ignores the day if it's today
	// This is useful for the tail page + searches within a single day
	function formatTimestamp(when) {
		if (when.isSame(new Date(), 'day'))
			return when.format(SHORT_TIMESTAMP_FORMAT); // Timestamp is for today, ignore the date
		else
			return when.format(LONG_TIMESTAMP_FORMAT); // Timestamp is not today, include the date
	}

	function addLine(event) {
		if (EVENT_FILTER(event)) {
			var tr = $('<tr/>').addClass('logline');

			tr.append($('<td/>').addClass('log_endpoint').text(ENDPOINT_RENDERER(event)));
			tr.append($('<td/>').addClass('log_when').text(formatTimestamp(moment(event.when))));
			tr.append($('<td/>').addClass('log_level').text(LEVEL_NAMES[event.level]));
			tr.append(MESSAGE_RENDERER(event, $('<td/>').addClass('log_message')));

			tr.data('e', event);

			// Keep track of the last time we received a mousedown event.
			// When we receive a click we'll need to make sure that the
			// corresponding mousedown event was <= 150ms ago, this
			// ensures that highlighting text in the cell doesn't cause
			// the cell to expand/contract
			tr.mousedown(function () {
				lastTableRowMousedown = new Date();
			});

			tr.click(function () {
				if (lastTableRowMousedown) {
					var prev = lastTableRowMousedown.getTime();
					var now = new Date().getTime();

					if (now - prev <= 150) {
						toggleEventExpansion(this);
					}
				}
			});

			tr.insertBefore(END_OF_LOG_TABLE);

			// If this is a new endpoint make sure we keep track of it
			if (!(event.endpoint in ALL_ENDPOINTS)) {
				addEndpoint(event.endpoint);
			}

			// TODO recognise when a previously-http://unknown instance id gets an endpoint
			// TODO when this happens, add an entry in a fixup array of instance id -> endpoint and rerender()
			if (event.endpoint == 'http://unknown') {
				OVERRIDE_ENDPOINTS[event.instanceId] = event.endpoint;
			}
			else if (OVERRIDE_ENDPOINTS[event.instanceId] == 'http://unknown') {
				OVERRIDE_ENDPOINTS[event.instanceId] = event.endpoint;

				rerender(
						function (e) {
							return (e.endpoint == 'http://unknown');
						},
						function (e) {
							if (e.endpoint == 'http://unknown' && e.instanceId in OVERRIDE_ENDPOINTS) {
								e.endpoint = OVERRIDE_ENDPOINTS[e.instanceId];
								return e;
							}
							else {
								return null;
							}
						});
			}
		}
	}

	function toggleEventExpansion(clickedElement) {
		var tr = $(clickedElement).closest('tr.logline');
		var event = tr.data('e');
		var expanded = tr.data('expanded');

		if (!event) {
			throw "Could not read event from log line!";
		}

		if (expanded == true) {
			tr.data('expanded', null);

			MESSAGE_RENDERER(event, tr.find('td.log_message'));
		}
		else {
			tr.data('expanded', true);

			var td = tr.find('td.log_message');
			td.empty();

			var msg = $('<pre />');
			msg.text(event.message);
			td.append(msg);

			td.append($('<br />'));

			td.append($('<div/>').text('Endpoint: ' + event.endpoint));
			td.append($('<div/>').text('Instance ID: ' + event.instanceId));
			td.append($('<div/>').text('Logger: ' + event.category));
			td.append($('<div/>').text('Trace ID: ' + event.traceId));
			td.append($('<div/>').text('User ID: ' + event.userId));
			td.append($('<div/>').text('Thread ID: ' + event.threadId));

			if (event.exceptionId != null && event.exceptionId.length > 0) {
				var exceptionId = $('<div/>').text('Exception ID: ' + event.exceptionId);

				// TODO make exceptionId a link to search logs for similar exceptions?

				td.append(exceptionId);

				var ex = $('<pre/>')
				ex.text(event.exception);

				td.append(ex);
			}

		}
	}

	function addEndpoint(endpoint) {
		ALL_ENDPOINTS[endpoint] = true;

		var previouslyChecked = getFilteredEndpoints();

		var options = $('#filterEndpointsOptions');
		options.empty();

		var keys = Object.keys(ALL_ENDPOINTS).sort();

		for (var i = 0; i < keys.length; i++) {
			var li = $('<li/>');
			var label = $('<label class="checkbox control-label"/>');


			var checkbox = $('<input type="checkbox"/>').data('endpoint', keys[i]).attr('checked', previouslyChecked.includes(keys[i]))
			label.append(checkbox);
			label.append(" " + keys[i]);
			li.append(label);

			// Stop the dropdown closing when clicking on a checkbox
			li.click(function (e) {
				var me = $(this);

				e.stopPropagation();
			});

			// Refilter the log lines when a selection is made
			checkbox.change(function () {
				refilter();
			});

			options.append(li);
		}
	}

	// eventSelector is optional, if it is specified then it should return true for lines which should be rerendered
	// eventMutator is optional, if it returns a non-null value then that return value is saved as the event data
	function rerender(eventSelector, eventMutator) {
		var endpointRenderMode = $("#renderEndpointOptions input[type=radio]:checked").val();

		if (endpointRenderMode == "full")
			ENDPOINT_RENDERER = endpointRenderFull;
		else
			ENDPOINT_RENDERER = endpointRenderShort;

		$("#renderEndpointSummary").text(" (" + endpointRenderMode + ")");

		// Now rerender the lines
		// N.B. we currently only rerender the timestamp and endpoint
		$("tr.logline").each(function () {
			var tr = $(this);
			var event = tr.data('e');

			if (eventSelector === undefined || eventSelector(event)) {
				// Allow the event mutator to modify events
				if (eventMutator !== undefined) {
					event = eventMutator(event);

					if (event)
						tr.data('e', event);
				}

				var endpoint = tr.find("td.log_endpoint");
				endpoint.text(ENDPOINT_RENDERER(event));

				var timestamp = tr.find("td.log_when");
				timestamp.text(formatTimestamp(moment(event.when)));
			}
		});
	}

	function refilter() {
		var permittedEndpoints = getFilteredEndpoints();
		var minLevel = $("#filterLevelOptions input[type=radio]:checked").val();

		// Update the UI to reflect the number of endpoint filters
		if (permittedEndpoints.length == 0)
			$("#filterEndpointsSummary").text("");
		else
			$("#filterEndpointsSummary").text(" (" + permittedEndpoints.length + ")");

		if (minLevel > 2)
			$("#filterLevelSummary").text(" (" + LEVEL_NAMES[minLevel] + ")");
		else
			$("#filterLevelSummary").text("");

		if (permittedEndpoints.length == 1) {
			$('.log_endpoint').hide();
		}
		else {
			$('.log_endpoint').show();
		}

		if (permittedEndpoints.length == 0 && minLevel <= 2)
			setEventFilter(function () {
				return true;
			});
		else
			setEventFilter(function (event) {
				return (permittedEndpoints.length == 0 || permittedEndpoints.includes(event.endpoint)) && event.level >= minLevel;
			});
	}

	function setEventFilter(newFilterFunction) {
		EVENT_FILTER = newFilterFunction;

		var rows = $('#loglines tr').slice(0, -1);

		rows.show();

		rows.each(function () {
			var row = $(this);
			var event = row.data('e');

			if (!EVENT_FILTER(event))
				row.hide();
		});
	}

	function getFilteredEndpoints() {
		var checked = [];
		$('#filterEndpointsOptions :checkbox:checked').each(function () {
			checked.push($(this).data('endpoint'));
		});

		return checked;
	}
	/*]]>*/
	</script>

	<p th:substituteby="includes :: footer"/>
</div>

<p th:substituteby="includes :: htmlfoot"/>
</body>
</html>
